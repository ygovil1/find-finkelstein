<!DOCTYPE html>
<html lang="en">

<head>
	<title>find finkelstein</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		html,
		body {
			width: 100%;
			height: 100%;
		}

		body {
			background-color: #ffffff;
			margin: 0;
			overflow: hidden;
			font-family: arial;
		}

		#blocker {
			position: absolute;
			width: 100%;
			height: 100%;
			background-color: rgba(0, 0, 0, 0.5);
		}


		#instructions {
			width: 100%;
			height: 100%;
			display: -webkit-box;
			display: -moz-box;
			display: box;
			-webkit-box-orient: horizontal;
			-moz-box-orient: horizontal;
			box-orient: horizontal;
			-webkit-box-pack: center;
			-moz-box-pack: center;
			box-pack: center;
			-webkit-box-align: center;
			-moz-box-align: center;
			box-align: center;
			color: #ffffff;
			text-align: center;
			cursor: pointer;
		}
	</style>
</head>


<body>
	<script src="js/three.js"></script>
	<script src="js/PointerLockControls.js"></script>
	<script src="js/OBJLoader.js"></script>
	<script src="js/ColladaLoader.js"></script>

	<div id="blocker">

		<div id="instructions">
			<span style="font-size:40px">Looking for Finkelstein?</span>
			<br /><br>
			Welcome to Firestone!<br><br>
			You need to submit your 426 Dean's Date assignment but you can't find your Graphics professor! Gather clues to find him. <br><br>
			Move forward and backward with Up and Down keys. Rotate views with your mouse.<br><br>
			Press Esc to pause game. Click anywhere to begin.
		</div>

	</div>

	<script>
		var camera, scene, renderer, controls;
		var objects = [];
		var raycaster;

		var moveForward = false;
		var moveBackward = false;
		var moveLeft = false;
		var moveRight = false;
		var canJump = false;

		var prevTime = performance.now();

		var velocity = new THREE.Vector3();
		var direction = new THREE.Vector3();
		var vertex = new THREE.Vector3();
		var color = new THREE.Color();

		init();
		animate();

		function init() {
			camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
			camera.position.set(-100, 50, 200); // Set position like this
			camera.lookAt(new THREE.Vector3(-100, 50, -250));
			scene = new THREE.Scene();
			scene.background = new THREE.Color(0xffffff);
			scene.fog = new THREE.Fog(0xffffff, 0, 750);
			var light = new THREE.HemisphereLight(0xe5ceae, 0x789ea0, 0.75);
			light.position.set(0.5, 1, 0.75);
			scene.add(light);

			controls = new THREE.PointerLockControls(camera);


			var blocker = document.getElementById('blocker');
			var instructions = document.getElementById('instructions');
			instructions.addEventListener('click', function () {
				controls.lock();
			}, false);


			controls.addEventListener('lock', function () {        // ?????
				instructions.style.display = 'none';
				blocker.style.display = 'none';
			});

			controls.addEventListener('unlock', function () {      // ?????
				blocker.style.display = 'block';
				instructions.style.display = '';
			});

			scene.add(controls.getObject());


			var onKeyDown = function (event) {
				switch (event.keyCode) {
					case 38: // up
					case 87: // w
						moveForward = true;
						break;
					case 37: // left
					case 65: // a
						moveLeft = true;
						break;
					case 40: // down
					case 83: // s
						moveBackward = true;
						break;
					case 39: // right
					case 68: // d
						moveRight = true;
						break;
					case 32: // space
						if (canJump === true) velocity.y += 350;
						canJump = false;
						break;
				}
			};
			var onKeyUp = function (event) {
				switch (event.keyCode) {
					case 38: // up
					case 87: // w
						moveForward = false;
						break;
					case 37: // left
					case 65: // a
						moveLeft = false;
						break;
					case 40: // down
					case 83: // s
						moveBackward = false;
						break;
					case 39: // right
					case 68: // d
						moveRight = false;
						break;
				}
			};

			document.addEventListener('keydown', onKeyDown, false);
			document.addEventListener('keyup', onKeyUp, false);



			raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, - 1, 0), 0, 10);

			// back wall
			var southWallGeometry = new THREE.PlaneBufferGeometry(150, 400, 20, 20);
			southWallGeometry.rotateZ(- Math.PI / 2);
			southWallGeometry.translate(0, 75, -250);

			// right wall
			var rightWallGeometry = new THREE.PlaneBufferGeometry(150, 500, 20, 20);
			rightWallGeometry.rotateZ(-Math.PI/2);
			rightWallGeometry.rotateY(-Math.PI/2);
			rightWallGeometry.translate(200, 75, 0);

			// left wall
			var leftWallGeometry = new THREE.PlaneBufferGeometry(150, 500, 20, 20);
			leftWallGeometry.rotateZ(Math.PI/2);
			leftWallGeometry.rotateY(Math.PI/2);
			leftWallGeometry.translate(-200, 75, 0);

			// front wall
			var frontWallGeometry = new THREE.PlaneBufferGeometry(150, 400, 20, 20);
			frontWallGeometry.rotateZ(-Math.PI/2);
			frontWallGeometry.translate(0, 75, 250);

			// floor rendering                TODO: fix to Firestone floor!
			var floorGeometry = new THREE.PlaneBufferGeometry(400, 500, 10, 10);
			floorGeometry.rotateX(- Math.PI / 2);
			var position = floorGeometry.attributes.position;
			floorGeometry = floorGeometry.toNonIndexed(); // ensure each face has unique vertices

			// ceiling rendering                TODO: fix to Firestone floor!
			var ceilGeometry = new THREE.PlaneBufferGeometry(400, 500, 10, 10);
			ceilGeometry.rotateX(- Math.PI / 2);
			ceilGeometry.translate(0, 150, 0);
			
			// add bookshelves
			let book_scale = new THREE.Vector3(0.5, 1, 1);
			let book_rotation = new THREE.Vector3(0, Math.PI, 0);
			let zero_rot = new THREE.Vector3(0, 0, 0);
			loadObject("./obj/bookshelf/model.dae", new THREE.Vector3(-70, 36, 0), book_scale, book_rotation);
			loadObject("./obj/bookshelf/model.dae", new THREE.Vector3(-70, 0, 0), book_scale, zero_rot);
			loadObject("./obj/bookshelf/model.dae", new THREE.Vector3(-70, 36, -35), book_scale, book_rotation);
			loadObject("./obj/bookshelf/model.dae", new THREE.Vector3(-70, 0, -35), book_scale, zero_rot);

			// add hanging lamps to scene
			let lamp_scale = new THREE.Vector3(7, 7, 7);
			loadObject("./obj/light/model.dae", new THREE.Vector3(-120, 100, 0), lamp_scale, zero_rot);
			loadObject("./obj/light/model.dae", new THREE.Vector3(-120, 100, 80), lamp_scale, zero_rot);
			loadObject("./obj/light/model.dae", new THREE.Vector3(-120, 100, -80), lamp_scale, zero_rot);

			loadObject("./obj/light/model.dae", new THREE.Vector3(120, 100, 0), lamp_scale, zero_rot);
			loadObject("./obj/light/model.dae", new THREE.Vector3(120, 100, 80), lamp_scale, zero_rot);
			loadObject("./obj/light/model.dae", new THREE.Vector3(120, 100, -80), lamp_scale, zero_rot);
			
			// add lights inside lamps
			addPointLight(new THREE.Vector3(-120, 80, 0), 0xf2d637, 90);
			addPointLight(new THREE.Vector3(-120, 80, 80), 0xf2d637, 90);
			addPointLight(new THREE.Vector3(-120, 80, -80), 0xf2d637, 90);

			addPointLight(new THREE.Vector3(120, 80, 0), 0xf2d637, 90);
			addPointLight(new THREE.Vector3(120, 80, 80), 0xf2d637, 90);
			addPointLight(new THREE.Vector3(120, 80, -80), 0xf2d637, 90);

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			var floortexture = new THREE.TextureLoader().load('textures/carpet.jpg', render);
			floortexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
			floortexture.wrapS = floortexture.wrapT = THREE.RepeatWrapping;
			floortexture.offset.set(0, 0);
			floortexture.repeat.set(40, 40);
			
			var floorMaterial = new THREE.MeshStandardMaterial({ map: floortexture});

			var floor = new THREE.Mesh(floorGeometry, floorMaterial);
			scene.add(floor);

			// add walls
			var wallMaterial = new THREE.MeshStandardMaterial({ color: 0xfffaef, side: THREE.DoubleSide});
			var back_wall = new THREE.Mesh(southWallGeometry, wallMaterial);
			scene.add(back_wall);

			var right_wall = new THREE.Mesh(rightWallGeometry, wallMaterial);
			scene.add(right_wall);

			var left_wall = new THREE.Mesh(leftWallGeometry, wallMaterial);
			scene.add(left_wall);

			var front_wall = new THREE.Mesh(frontWallGeometry, wallMaterial);
			scene.add(front_wall);

			var ceilMaterial = new THREE.MeshStandardMaterial({ color: 0xa8a7a4, side: THREE.DoubleSide});
			var ceil = new THREE.Mesh(ceilGeometry, ceilMaterial);
			scene.add(ceil);

			window.addEventListener('resize', onWindowResize, false);
		}

		// adds point light to the specified position
		function addPointLight(pos, color, intensity) {
			var light = new THREE.PointLight(color, 1, intensity);
			light.position.set(pos.x, pos.y, pos.z);
			scene.add(light);
		}

		// loads object from the given filepath and adds it to the scene
		function loadObject(filepath, pos, scale, rotation) {

			var loader = new THREE.ColladaLoader();
			var obj;
			loader.convertUpAxis = true;
			loader.load(filepath, function ( collada ) {

				obj = collada.scene;
				obj.scale.x = scale.x;
				obj.scale.y = scale.y;
				obj.scale.z = scale.z;
				obj.position.x= pos.x;
				obj.position.y= pos.y;
				obj.position.z= pos.z;
				obj.rotation.x += rotation.x;
				obj.rotation.y += rotation.y;
				obj.rotation.z += rotation.z;
				obj.castShadow = true;
				objects.push(obj);
				scene.add(obj);
			});
		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		}


		function animate() {                                     // This part is for jumping, which requires animation --> good to know, unsure if necessary in our game, we can keep just in case? Or we can have one of the clues, such as the fuse box, that can only be seen if you jump up?
			requestAnimationFrame(animate);

			if (controls.isLocked === true) {
				raycaster.ray.origin.copy(controls.getObject().position);
				raycaster.ray.origin.y -= 10;
				var intersections = raycaster.intersectObjects(objects);
				var onObject = intersections.length > 0;
				var time = performance.now();
				var delta = (time - prevTime) / 1000;
				velocity.x -= velocity.x * 10.0 * delta;
				velocity.z -= velocity.z * 10.0 * delta;
				velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass
				direction.z = Number(moveForward) - Number(moveBackward);
				direction.x = Number(moveLeft) - Number(moveRight);
				direction.normalize(); // this ensures consistent movements in all directions
				if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
				if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;
				if (onObject === true) {
					velocity.y = Math.max(0, velocity.y);
					canJump = true;
				}


				// Code to handle not going through objects
				// ------------------ START ---------------------
				var curr_pos = controls.getObject().position.clone();
				var obj_too_close = [];		// list of objects that camera is too close to
				var new_pos;
				for (var i = 0; i < objects.length; i++) {
				  var obj_pos = objects[i].position;
				  if (obj_pos.distanceTo(curr_pos) < 10)  // too close
				    obj_too_close.push(objects[i]);
				}

				if (obj_too_close.length == 0) {				// not too close to any obj
				  controls.getObject().translateX(velocity.x * delta);
				  controls.getObject().position.y += (velocity.y * delta); // new behavior
				  controls.getObject().translateZ(velocity.z * delta);
				}
				else {
				  for (var i = 0; i < obj_too_close.length; i++) {
				    var obj_pos = obj_too_close[i].position;

				    var dist = obj_pos.distanceTo(curr_pos);
				    var new_pos = curr_pos.clone();
				    var x_change = new THREE.Vector3(velocity.x * delta, 0, 0);
				    var y_change = new THREE.Vector3(0, velocity.y * delta, 0);
				    var z_change = new THREE.Vector3(0, 0, velocity.z * delta);

				    if (new_pos.clone().add(x_change).distanceTo(obj_pos) > dist)
				      controls.getObject().translateX(velocity.x * delta);
				    if (new_pos.clone().add(y_change).distanceTo(obj_pos) > dist)
				      controls.getObject().position.y += (velocity.y * delta);
				    if (new_pos.clone().add(z_change).distanceTo(obj_pos) > dist)
				      controls.getObject().translateZ(velocity.z * delta);
				  }
				}
				// ------------------ END ---------------------



				if (controls.getObject().position.y < 25) {
					velocity.y = 0;
					controls.getObject().position.y = 25;
					canJump = true;
				}
				prevTime = time;
			}
			renderer.render(scene, camera);
		}

		function render() {
			requestAnimationFrame(render);
			renderer.render(scene, camera);
		}


	</script>
</body>

</html>
